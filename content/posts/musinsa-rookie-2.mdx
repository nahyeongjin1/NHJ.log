---
title: '무신사 AI Native Engineer 2차 코딩테스트 회고'
excerpt: '3시간 안에 NestJS + TypeORM + PostgreSQL로 수강신청 API를 구현하며 Claude Code를 활용한 과정과, 동시성 제어에서 놓친 부분을 되짚어본다.'
createdAt: '2026-02-14T10:23:00.000Z'
updatedAt: '2026-02-16T06:04:00.000Z'
tags: ['Claude Code', 'NestJS', 'TypeORM', 'PostgreSQL', 'Concurrency', 'Docker Compose']
thumbnail: 'https://pub-ee38f5a9ca244fbb9948d2fb7fe576bd.r2.dev/images/posts/307bdc82-a936-8004-a1db-e0be273d1ecf/thumbnail.webp'
---

## TL;DR

---

<Callout icon="💡">
1. 3시간 안에 NestJS(처음 사용) + TypeORM + PostgreSQL로 대학교 수강신청 REST API를 구현했다. 
동시성 제어가 핵심 요구사항이었고, 비관적 락(`SELECT FOR UPDATE`)으로 해결했다.

1. Claude Code를 2개 세션(계획/리뷰 + 구현)으로 분리해서 사용했는데, 같은 관점을 공유하는 세션끼리는 서로의 맹점을 잡아주지 못한다는 한계를 깨달았다.

1. Course에만 락을 걸고 Student에는 안 걸어서, 동일 학생이 서로 다른 강좌를 동시에 신청하면 18학점 제한이 뚫리는 버그가 있었다. 
</Callout>

## 시험 개요

---

| 항목 | 내용 |
| --- | --- |
| 시험 | 무신사 AI Native Engineer 2차 코딩테스트 |
| 일시 | 2026-02-08 (일) 15:00 ~ 18:00 (3시간) |
| 과제 | 대학교 수강신청 REST API 서버 구현 |
| 핵심 | "정원 1명 남은 강좌에 100명이 동시 신청해도, 정확히 1명만 성공해야 합니다" |
| 제출 | 시간 내 최종 commit/push |

1차가 알고리즘 문제풀이였다면, 2차는 성격이 완전히 다르다.
3시간 안에 **백엔드 서비스를 처음부터 설계하고 구현**해야 한다.
기획팀의 요구사항 문서는 의도적으로 불친절하게 주어지고, 명시되지 않은 부분은 스스로 판단해서 문서화해야 한다.

그리고 무엇보다 이 시험의 핵심은 **AI를 어떻게 활용하는가**였다.

<Image src="https://pub-ee38f5a9ca244fbb9948d2fb7fe576bd.r2.dev/images/posts/307bdc82-a936-8004-a1db-e0be273d1ecf/309bdc82-a936-80c9-85ca-f3dfd74d87de.png" />

## 도구 선택

---

### Claude Code를 쓴 이유

무신사에서 Codex를 무료로 제공해줬지만, 평소에 쓰던 Claude Code를 선택했다. 
3시간이라는 제한 안에서 새 도구를 익히는 리스크보다 익숙한 도구의 효율을 택한 판단이었다.

Claude Code를 좋아하는 이유가 몇 가지 있다:

- `.claude` 폴더 기반의 문서화 — `CLAUDE.md`에 프로젝트 지침을 적어두면 매 대화에서 자동으로 컨텍스트에 포함된다

- `@` 링크로 필요한 문서만 선택적으로 불러올 수 있어서 불필요한 컨텍스트 누적을 막을 수 있다

- 터미널 네이티브 — 윈도우 환경이지만 WSL에서 모든 작업을 하는 나한테 안정감을 주는 환경이다

### 처음 추천 받은 기술 스택

<Image src="https://pub-ee38f5a9ca244fbb9948d2fb7fe576bd.r2.dev/images/posts/307bdc82-a936-8004-a1db-e0be273d1ecf/309bdc82-a936-80f6-b3ff-df5a837c7205.png" />

Claude Code와 PROBLEM.md를 읽으며 논의하던 중 가장 먼저 추천 받은 기술 스택이다.
하지만 결국 작업을 시작할 때는 이 중 하나도 선택하지 않고 다른 도구들로 진행하게 됐다.
이에 대한 내용을 더 풀어보고자 한다.

### NestJS

평소에는 주어진 상황에 따라 프레임워크를 골라서 쓰려고 하는 편인데 학생이다보니 적은 인원, 예산 등을 중요하게 고려해야헸다.
그렇다보니 가볍고, 자유롭고, 학습곡선이 완만하며 유연한 프레임워크를 사용하게 되는 경향이 있었다.
결국 최근에는 주로 Express, Fastify, FastAPI를 선택했던 것 같다.

하지만 Claude Code와 작업하기 시작하면서 새로운 프레임워크의 학습 곡선이 많이 낮아졌다.
공식 문서를 MCP로 참조하며 작업하니 처음 쓰는 프레임워크도 버그 없이 사용할 수 있다.
덕분에 "익숙 vs 최적" 사이에서 후자를 선택하는 게 부담이 줄었다.

<Image src="https://pub-ee38f5a9ca244fbb9948d2fb7fe576bd.r2.dev/images/posts/307bdc82-a936-8004-a1db-e0be273d1ecf/309bdc82-a936-804f-82a6-f98e0dfa2877.png" />

그리고 제일 중요한건 언어만 선택지에서 벗어나지 않는다면 프레임워크가 **자유 선택**이었다.
Node.js의 개발 경험을 선호하는 나에게는 기회가 찾아온 것이다.
평소에 사용해보고 싶었지만 스프링 공화국이라 포기했던 NestJS를 사용할 기회가.

NestJS를 고른 이유는 Module/Controller/Provider 구조가 엄격하게 정해져 있기 때문이다.
Spring처럼 규격이 명확하면서도 TypeScript 기반이라 보일러플레이트가 적다.
3시간이라는 제한 시간 안에서 빠르게 구조를 잡으면서도 AI와 협업할 때 일관된 코드가 나올 거라 판단했다.
실제로 AI가 생성한 코드를 리뷰하기도 훨씬 쉬웠다.

### PostgreSQL

동시성 제어와 데이터 정합성이 과제의 핵심이었기 때문에, DB 레벨에서 확실하게 잡고 싶었다.
애플리케이션 레벨 락(인메모리 mutex 등)은 싱글 인스턴스에서만 유효하니 scale-out 하면 무용지물이다.

수강신청처럼 데이터 정합성이 중요한 도메인에서는 PostgreSQL의 `SELECT FOR UPDATE`(pessimistic locking)가 가장 확실한 선택이라고 판단했다.
SQLite 인메모리라는 더 가벼운 선택지도 있었지만, 실제 프로덕션과 거리가 먼 선택이라고 판단했다.
PostgreSQL을 선택한 건 TypeORM 공식 문서와 예시가 PostgreSQL 기준으로 작성된 경우가 많아서다.
MCP로 문서를 참조하며 작업할 때 예시 코드를 그대로 적용하기 편했다.

### Docker

Docker Compose를 선택한 가장 큰 이유는 **평가자의 테스트 편의성**이었다. 
PROBLEM.md에 "평가자가 빌드 및 실행에 실패하면 이후 평가가 어렵습니다"라고 명시되어 있었다.
`docker compose up --build` 한 줄이면 PostgreSQL 컨테이너 + 앱 컨테이너 + 시드 데이터 생성까지 전부 완료된다.
평가자 PC에 Node.js나 PostgreSQL이 설치되어 있지 않아도 Docker만 있으면 된다.
환경 차이로 인한 "제 컴퓨터에서는 되는데요" 문제를 원천 차단할 수 있다.

재미있는 건, Claude가 처음에 Java + Spring Boot + H2를 제안했다는 것이다.
내가 "NestJS는 어렵나?"라고 물었고, 다시 SQLite를 추천했을 때 "도커로 다른 DB 실행하면 안 됨?"이라고 물어서 최종적으로 PostgreSQL에 도달했다.

## AI와의 협업 방식

---

### 2개 세션 전략

시험 동안 Claude Code 세션을 2개로 분리해서 운영했다:

- **메인 세션**: 전체 계획 수립, 문서 작성, 코드 리뷰, git 관리

- **구현 세션**: 계획 문서를 기반으로 실제 코드 구현

메인 세션이 큰 그림을 잡고 있으면서, 구현 세션의 결과물을 검증하는 구조였다. 
구현 세션에서 커밋이 올라오면 메인 세션에서 빌드/테스트를 돌리고, 문서와 구현이 일치하는지 확인했다.

### CLAUDE.md로 AI 행동 제어

auto accept를 쓰지 않기 때문에 (모든 도구 호출을 직접 승인), AI의 작업 흐름이 자주 끊기면 속도가 느려진다.
그래서 `CLAUDE.md`에 코딩 원칙, TDD 방식, 커밋 컨벤션, 테스트 우선순위 등을 상세하게 적어서 **AI가 매번 물어보지 않고도 올바른 방향으로 작업하게** 만들었다.

태스크가 완료될 때마다 `CLAUDE.md`의 구현 상태 체크리스트를 업데이트해서, 어느 세션에서든 현재 진행 상황을 파악할 수 있게 했다.

### MCP로 공식 문서 참조

Claude Code에 Context7 MCP를 연결해서 사용했다. 
Context7은 라이브러리의 공식 문서를 실시간으로 조회할 수 있는 MCP 서버다. 
사용 여부를 자주 언급해주면 사용할 가능성이 높아지므로 CLAUDE.md에도 명시해두었다.

<Image src="https://pub-ee38f5a9ca244fbb9948d2fb7fe576bd.r2.dev/images/posts/307bdc82-a936-8004-a1db-e0be273d1ecf/309bdc82-a936-80a3-858d-d0b3bbb2cdd6.png" />

Context7의 덕을 본 순간이 여럿 있었지만 하나만 꼽아보았다.
e2e 테스트에서 테스트 간 데이터를 정리하기 위해 AI가 `repository.delete({})`를 작성했는데, 테스트를 실행하니 다음과 같은 에러가 발생했다.

<Image src="https://pub-ee38f5a9ca244fbb9948d2fb7fe576bd.r2.dev/images/posts/307bdc82-a936-8004-a1db-e0be273d1ecf/309bdc82-a936-802d-8344-fe524960072d.png" />

필자는 TypeORM을 사용해본 적이 없기에 깊게 개입할 수 없었고, AI가 혼자 해결하려고 시도하기에 interrupt를 발생시켰다.
Claude Code가 해당 라이브러리의 명확한 사용법을 알지 못하기에 발생하는 문제라고 판단했고 바로 Context7을 사용하라고 지시했다.

<Image src="https://pub-ee38f5a9ca244fbb9948d2fb7fe576bd.r2.dev/images/posts/307bdc82-a936-8004-a1db-e0be273d1ecf/309bdc82-a936-8024-94e1-ceb2953e16d9.png" />

AI가 Context7으로 TypeORM 공식 문서를 조회하고, `repository.clear()`(TRUNCATE)가 올바른 API라는 걸 확인해서 즉시 해결했다.
AI가 추측으로 해결하려 했으면 몇 번 더 시행착오를 겪었을 것이다. 
공식 문서를 직접 참조하게 하는 게 시간도 아끼고 복잡한 방식으로 해결하지 않기에 코드 가독성도 올라간다.

### 인간의 역할: 방향 설정자 + 브레이크

대화 로그를 돌아보면, 내가 한 일이 반복적으로 나타난다:

**AI의 제안을 수정하거나 거부:**

- Claude가 Java + Spring Boot를 제안 → NestJS로 변경

- Claude가 SQLite를 추천 → PostgreSQL (Docker)로 변경

- Claude가 불필요한 문서(ARCHITECTURE.md)를 작성하려 함 → "PROBLEM.md에서 요구하는 문서만"

**속도보다 방향을 우선:**

- 구현으로 달려가려는 AI를 여러 번 멈추고 문서부터 정리하게 함

- TDD를 건너뛰고 코드를 한꺼번에 작성하려는 AI를 제지: "우리 TDD 기반으로 작업해야돼. CLAUDE.md 다시 확인해봐."

**품질 게이트:**

- TypeORM API를 모를 때 추측으로 해결하려는 AI에게 context7(공식 문서 조회) 사용을 강제

- 커밋 단위가 너무 클 때 "이미 만든 걸 다 커밋하기보다는, 정확히 작업한 파일들만 커밋"

AI가 코드 작성 속도를 담당하고, 나는 방향과 품질을 관리하는 구조였다.

## 핵심 기술 결정: 동시성 제어

---

### 비관적 락 전략

수강신청의 핵심 흐름:

```text
트랜잭션 시작
→ Student 조회 (존재 확인)
→ Course 조회 + FOR UPDATE (비관적 락)
→ 정원 확인
→ 중복 신청 확인
→ 학점 확인 (18학점 제한)
→ 시간충돌 확인
→ Enrollment INSERT + enrolled 카운트 증가
→ 커밋 (락 해제)
```

Course row에 `FOR UPDATE` 락을 걸면, 같은 강좌에 대한 동시 요청이 직렬화된다. 
정원이 1명 남았을 때 100명이 동시에 신청해도 한 명씩 순차적으로 처리되므로 정확히 1명만 성공한다.

### LEFT JOIN + FOR UPDATE 함정

구현 중에 실제로 부딪힌 이슈가 있었다. 
TypeORM에서 `relations` 옵션과 `lock`을 동시에 쓰면, 내부적으로 `LEFT JOIN ... FOR UPDATE`가 생성되는데, PostgreSQL은 이를 허용하지 않는다:

```text
QueryFailedError: FOR UPDATE cannot be applied to the nullable side of an outer join
```

Docker에서 처음 실행했을 때 500 에러가 나서 로그를 확인해보니 이 에러였다. 
`relations`를 빼고 락 쿼리에서는 Course 데이터만 가져오는 것으로 해결했다. 
주석으로도 남겨뒀다:

```typescript
// 강좌 조회 + FOR UPDATE 비관적 락 (relations 없이 락 — LEFT JOIN과 FOR UPDATE 비호환)
const course = await queryRunner.manager.findOne(Course, {
  where: { id: dto.courseId },
  lock: { mode: "pessimistic_write" },
  // relations: ['professor', 'department'], 
});
```

### 그리고, 놓친 것: Student 락 누락

**이 과제에서 가장 큰 아쉬움이다.**

현재 코드는 Course에만 비관적 락을 건다. 
이 말은, **서로 다른 강좌**에 대한 요청은 병렬로 실행된다는 뜻이다.

동일 학생이 서로 다른 강좌 2개를 동시에 신청하면 어떻게 될까:

```text
학생 A (현재 15학점), 동시에 강좌 X(3학점)와 강좌 Y(3학점) 신청

요청1 (강좌 X)                    요청2 (강좌 Y)
─────────────                    ─────────────
BEGIN                            BEGIN
Student 조회 (락 없음)            Student 조회 (락 없음)
Course X FOR UPDATE               Course Y FOR UPDATE  ← 서로 다른 row라 대기 없음
학점 확인: 15+3=18 ≤ 18 ✓         학점 확인: 15+3=18 ≤ 18 ✓  ← 요청1의 INSERT가 아직 미커밋
INSERT enrollment                 INSERT enrollment
COMMIT                            COMMIT

결과: 학생 A = 21학점 (18학점 초과!)
```

시간충돌도 같은 원리로 뚫린다. 
월요일 1교시 강좌 두 개를 동시에 신청하면 둘 다 "기존 수강 내역에 월 1교시 없음"으로 판단한다.

**해결 방법**: Student에도 비관적 락을 건다.

```typescript
// Student도 FOR UPDATE
const student = await queryRunner.manager.findOne(Student, {
  where: { id: dto.studentId },
  lock: { mode: "pessimistic_write" },
});
```

같은 학생의 동시 요청이 Student 락에서 직렬화되므로, 학점/시간충돌 검증이 정확해진다. 
데드락 방지를 위해 **항상 Student → Course 순서**로 락을 잡아야 한다.

**왜 놓쳤는가**: PROBLEM.md의 기획팀 메모가 "정원 1명 남은 강좌에 100명이 동시 신청"이라는 시나리오에 집중시켰다.
e2e 테스트도 이 시나리오만 검증했고, "같은 학생이 다른 강좌를 동시에 신청"하는 케이스는 떠올리지 못했다.

돌아보면 이건 **세션 설계의 한계**이기도 했다. 
메인 세션과 구현 세션이 같은 맥락을 공유하고 있었기 때문에, 둘 다 같은 프레임에 갇혔다.
만약 **적대적 검증 역할**의 세션을 별도로 뒀다면 — "이 동시성 제어를 어떻게 우회할 수 있을까?"라는 관점으로 코드를 분석하는 역할 — 이 버그를 시험 중에 잡았을 것이다.

같은 AI라도 프롬프트의 관점이 다르면 완전히 다른 결과를 낸다.
이건 이번 시험에서 얻은 가장 큰 교훈이다.

## 3시간의 시간 배분

---

### 실제 흐름

| 시간대 | 작업 |
| --- | --- |
| 15:00~15:30 | 요구사항 분석, 기술 스택 결정, [CLAUDE.md](http://claude.md/) 작성 |
| 15:30~16:00 | [REQUIREMENTS.md](http://requirements.md/), [API.md](http://api.md/), [README.md](http://readme.md/) 작성 |
| 16:00~16:30 | 인프라 + 엔티티 + 조회 API + TDD로 핵심 로직 구현 |
| 16:30~17:00 | Seed 데이터, Docker 통합, FOR UPDATE 버그 수정 |
| 17:00~17:30 | e2e 테스트 (동시성 100명, 학점, 시간충돌, 중복, 취소) |
| 17:30~17:50 | 테스트 보강, Swagger UI, DB 인덱스, 로깅 추가 |
| 17:50~18:00 | CLAUDE.md 루트 복사, 최종 merge + push |

### 두 가지 핵심 판단

**1. 처음 30분을 코드 없이 문서에 투자했다.**

3시간 중 30분이면 큰 비중이다. 
하지만 문서가 없으면 AI가 매번 방향을 물어보고, 내가 매번 답해야 한다. 
문서를 먼저 작성하고 CLAUDE.md에 링크해두면, 이후 구현 세션에서 AI가 독립적으로 작업할 수 있다.

다만 돌아보면 **30분도 부족했다**. 
메인 세션 하나로 문서를 작성하고 바로 구현에 들어갔는데, 별도의 검토 세션으로 계획을 점검하는 시간을 가졌다면 더 견고한 설계가 나왔을 것이다. 
Student 락 누락도 이 단계에서 잡을 수 있었다. 
"빨리 구현해야 한다"는 압박이 오히려 전체 품질을 낮췄다.

**2. merge를 2단계로 나눴다.**

핵심 기능 구현 전에 1차 merge로 main에 "동작하는 베이스라인"을 확보했다. 
PROBLEM.md에 

> 완성하지 못했더라도 반드시 제출하세요. 부분 구현도 평가 대상입니다

라고 적혀 있었기 때문에, **최악의 경우에도 제출 가능한 상태를 유지**하는 게 중요했다.

## 아쉬운 점

---

### 1. Student 락 누락 (위에서 상세히 다룸)

가장 큰 아쉬움. 적대적 검증 세션의 부재.

### 2. TDD가 부분적으로만 적용됨

schedule.util과 enrollment.service는 Red → Green → Refactor를 깔끔하게 지켰다.
하지만 조회 API(Student, Course, Professor)는 코드를 먼저 작성하고 테스트를 나중에 붙였다.
시간 압박 때문이었지만, 나중에 테스트 커버리지가 낮아서 헐레벌떡 테스트를 추가한 느낌이 남았다.

CLAUDE.md에 TDD 원칙을 명시해놓고 본인이 지키지 않은 셈이라 더 아쉽다.

### 3. synchronize: true

TypeORM의 `synchronize: true`는 앱 실행 시 엔티티 정의에 맞게 DB 스키마를 자동으로 변경한다.
개발 환경에서는 편리하지만, 프로덕션에서는 데이터 손실 위험이 있다.
`NODE_ENV`에 따라 분기하는 처리를 했어야 했는데 미처 생각하지 못했다.

### 4. 검증 순서

현재 수강신청 검증 순서가 정원 → 중복 → 학점 → 시간충돌인데, 이미 신청한 강좌를 다시 신청했는데 "정원이 가득 찼습니다"라고 응답하면 사용자가 혼란스럽다. 
중복 확인을 가장 먼저 하는 게 UX 관점에서 맞다.

## 면접을 앞두고

---

이번 코딩테스트에서 가장 크게 느낀 것은, **AI와의 협업에서 인간의 역할은 "방향"과 "검증"**이라는 점이다.

AI는 코드를 빠르게 작성하지만, 방향이 틀리면 빠르게 잘못된 곳으로 간다.
기술 스택을 결정하고, 불필요한 작업을 잘라내고, TDD를 강제하고, 커밋 단위를 관리하는 건 전부 내가 했다.

동시에, 인간은 아직 **orchestrator** 역할로서 필수적이라는 것도 확인했다.
AI는 방향을 잡아주면 빠르게 달리지만, 잡아주지 않으면 불필요한 곳에서 토큰을 소모하고 컨텍스트를 오염시킨다.
실제로 시험 중에도 AI가 불필요한 문서를 작성하려 하거나, TDD 원칙을 무시하고 코드부터 짜려는 걸 여러 번 멈춰 세웠다.
이런 개입이 없었으면 작업 시간이 훨씬 길어졌을 것이다.
AI의 속도를 온전히 활용하려면, 어디에 그 속도를 쓸지 결정하는 지휘자가 있어야 한다.

그리고 AI의 관점은 프롬프트에 의해 결정된다는 것도 배웠다.
구현하는 관점의 세션 2개로는 구현의 맹점을 찾기 어렵다.
적대적 관점 — "이걸 어떻게 깨뜨릴 수 있을까?" — 을 가진 별도의 검증 역할이 필요하다.

Student 락 누락은 아쉽지만, 이걸 발견하고 원인을 분석하고 해결책까지 도출한 과정 자체가 의미 있다고 생각한다.
완벽한 코드를 짜느냐보다, 문제를 발견했을 때 어떻게 접근하는가가 더 중요하니까.
